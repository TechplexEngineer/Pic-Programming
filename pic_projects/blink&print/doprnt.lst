     1: #include        <stdio.h>
     2: #include        <ctype.h>
     3: #include        <stdlib.h>
     4: #include        <string.h>
     5: #include        <stdarg.h>
     6: #include        <conio.h>
     7: #include        <sys.h>
     8: #include        <math.h>
     9: #include        <float.h>
    10: 
    11: /*
    12:  *      doprnt - versions depends on conditional compilation.
    13:  *      Can be customized with defines.
    14:  *
    15:  *      Copyright (C) 1993-2004 HI-TECH Software Pty. Ltd.
    16:  *
    17:  *      $Header$
    18:  *
    19:  */
    20: 
    21: #ifndef CUSTOM_PRINTF
    22: 
    23:  // define all flags, thus enabling all features
    24: 
    25: #define BASEM   0xC0
    26: #define OPTSIGN 0x00
    27: #define SPCSIGN 0x01
    28: #define MANSIGN 0x02
    29: #define NEGSIGN 0x03
    30: #define FILL    0x04
    31: #define LEFT    0x08
    32: #define LONG    0x10
    33: #define UPCASE  0x20
    34: #define TEN             0x00
    35: #define EIGHT   0x40
    36: #define SIXTEEN 0x80
    37: #define UNSIGN  0xC0
    38: #ifdef  __FLOAT
    39: #define EFMT    0x100
    40: #define GFMT    0x200
    41: #define FFMT    0x400
    42: #endif  // __FLOAT
    43: #define ALTERN  0x800
    44: #define POINTER 0x2000
    45: #define HEXUPCASE
    46: #define HEXLOWCASE
    47: 
    48:  // defines for ifdef only, not used as flags
    49: #define WIDTH   1               // width used
    50: #define STAR    1               // width or precision as an arg
    51: #define STRING  1               // %s used
    52: #define CHAR    1               // %c used
    53: #define PERCPERC        1       // %% used
    54: #define SPRINTF 1               // sprintf is used
    55: #define PRINTF  1               // printf is used
    56: #define MULTRAD 1               // handle multiple radices
    57: #define RETVALUE        1       // return value is needed
    58: 
    59: #else   // CUSTOM_PRINTF
    60: 
    61: #if     defined(HEXUPCASE) || defined(HEXLOWCASE)
    62: #define SIXTEEN
    63: #endif
    64: 
    65: #if     defined(HEXUPCASE) && defined(HEXLOWCASE)
    66: #ifndef UPCASE
    67: #define UPCASE
    68: #endif
    69: #endif
    70: 
    71:  // make sure we have the right values for each define
    72: #ifdef  OPTSIGN
    73: #undef  OPTSIGN
    74: #define OPTSIGN 0x00
    75: #endif
    76: #ifdef  SPCSIGN
    77: #undef  SPCSIGN
    78: #define SPCSIGN 0x01
    79: #endif
    80: #ifdef  MANSIGN
    81: #undef  MANSIGN
    82: #define MANSIGN 0x02
    83: #define SPCSIGN 0x01
    84: #endif
    85: #ifdef  NEGSIGN
    86: #undef  NEGSIGN
    87: #define NEGSIGN 0x03
    88: #endif
    89: #ifdef  FILL
    90: #define WIDTH   1
    91: #undef  FILL
    92: #define FILL    0x04
    93: #endif
    94: #ifdef  LEFT
    95: #undef  LEFT
    96:  // LEFT without WIDTH is meaningless
    97: #ifdef  WIDTH
    98: #define LEFT    0x08
    99: #endif
   100: #endif
   101: #ifdef  LONG
   102: #undef  LONG
   103: #define LONG    0x10
   104: #define __LONG  1
   105: #endif
   106: #ifdef  UPCASE
   107: #undef  UPCASE
   108: #define UPCASE  0x20
   109: #endif
   110: #ifdef  TEN     
   111: #undef  TEN     
   112: #define TEN             0x00
   113: #endif
   114: #ifdef  EIGHT
   115: #undef  EIGHT
   116: #define EIGHT   0x40
   117: #endif
   118: #ifdef  SIXTEEN
   119: #undef  SIXTEEN
   120: #define SIXTEEN 0x80
   121: #endif
   122: #ifdef  UNSIGN
   123: #undef  UNSIGN
   124: #define UNSIGN  0xC0
   125: #endif
   126: #ifdef  EFMT
   127: #undef  EFMT
   128: #define EFMT    0x100
   129: #endif
   130: #ifdef  GFMT
   131: #undef  GFMT
   132: #define GFMT    0x200
   133: #endif
   134: #ifdef  FFMT
   135: #undef  FFMT
   136: #define FFMT    0x400
   137: #endif
   138: #ifdef  ALTERN
   139: #undef  ALTERN
   140: #define ALTERN  0x800
   141: #endif
   142: #ifdef  POINTER
   143: #undef  POINTER
   144: #define POINTER 0x2000
   145: #ifndef SIXTEEN
   146: #define SIXTEEN 0x80
   147: #endif
   148: #endif
   149: #ifdef  PRECISION
   150: #undef  PRECISION
   151: #define PRECISION       0x4000
   152: #endif
   153: 
   154: #if     defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
   155: #undef  UNSIGN
   156: #define UNSIGN  0x40
   157: #define BASEM   UNSIGN
   158: #endif
   159: #if     defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
   160: #define MULTRAD 1
   161: #define BASEM   (UNSIGN)
   162: #endif
   163: #if     defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
   164: #define BASEM   EIGHT
   165: #define MULTRAD 1
   166: #endif
   167: #if     defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
   168: #define BASEM   SIXTEEN
   169: #define MULTRAD 1
   170: #endif
   171: #if     defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
   172: #define BASEM   (SIXTEEN|EIGHT)
   173: #define MULTRAD 1
   174: #endif
   175: 
   176: #endif
   177: 
   178:  // float code needs these flags
   179: #if     defined(EFMT) || defined(GFMT) || defined(FFMT)
   180: #ifndef __FLOAT
   181: #define __FLOAT 1
   182: #endif
   183: #define FLOATFORMAT     0x700
   184: #ifdef  PRECISION
   185: #define DEFPREC 0x1000
   186: #endif
   187: #endif
   188: 
   189: #ifdef  __FLOAT
   190: //#ifndef       MANSIGN
   191: //#define       MANSIGN 0x02
   192: //#endif
   193: //#ifndef       SPCSIGN
   194: //#define       SPCSIGN 0x01
   195: //#endif
   196: #ifndef NEGSIGN
   197: #define NEGSIGN 0x03
   198: #endif
   199: //#ifndef       WIDTH
   200: //#define       WIDTH   1
   201: //#endif
   202: #endif
   203: 
   204: #ifdef  SPCSIGN
   205: #define putsign()       pputc(flag & SPCSIGN ? '-' : '+')
   206: #else
   207: #define putsign()       pputc('-')
   208: #endif  // SPCSIGN
   209: 
   210: // were there ANY % formats defined?
   211: #if     defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
   212:         defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
   213: #define ANYFORMAT
   214: #else
   215: #undef  ANYFORMAT
   216: #endif
   217: 
   218: #ifdef  CHAR
   219: #ifndef PERCPERC
   220: #define PERCPERC
   221: #endif
   222: #endif
   223: 
   224: #if     !defined(PRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
   225: #error  Must define at least one of PRINTF SPRINTF or VSPRINTF
   226: #endif
   227: 
   228: #if     i8086 && SMALL_DATA
   229: #define CONST   far
   230: #else
   231: #define CONST   const
   232: #endif
   233: 
   234:  /* we don't need plus signs, use minus signs only if we have floats or signed ints */
   235: 
   236: #if     !defined(NEGSIGN) && defined(TEN)
   237: #define NEGSIGN 0x03
   238: #endif
   239: 
   240: #ifndef RETVALUE
   241: #define INCR_CNT        /*nix */
   242: #else
   243: #define INCR_CNT        ,(++ccnt)
   244: #endif
   245: 
   246: #if     defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
   247: #define FLAG_SIZE       unsigned short
   248: #else
   249: #define FLAG_SIZE       unsigned char
   250: #endif
   251: 
   252: 
   253: #if     (sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
   254: #define __LONG  1
   255: #endif
   256: 
   257: #if     sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
   258: #undef  frexp
   259: #define frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
   260: #elif   defined(_PSOC_)
   261: #undef  frexp
   262: #define frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
   263: #elif   sizeof(double) == 3 && DBL_MAX_EXP == 128
   264: #undef  frexp
   265: #define frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
   266: #endif
   267: 
   268: #if     defined(__FLOAT) && sizeof(double) == 8
   269: #define DOUBLE  1
   270: 
   271: extern double   _dto64i(double);
   272: extern double   _64itod(double);
   273: extern double   _div64(double, double);
   274: extern double   _divto64i(double, double);
   275: extern unsigned _div64ir(double, double);
   276: extern unsigned _mod64i10(double);
   277: 
   278: #else
   279: #define DOUBLE  0
   280: #endif
   281: 
   282: #ifdef  __LONG
   283: #define value   long
   284: #define NDIG    12              /* max number of digits to be printed */
   285: #else
   286: #define value   int
   287: #define NDIG    6               /* max number of digits to be printed */
   288: #endif
   289: 
   290: #if     DOUBLE
   291: union {
   292:         unsigned long   ul[40];
   293:         double          db[20];
   294: }       _fdp =
   295: {
   296: #if     !defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
   297: #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
   298: #endif
   299: #if     BIG_ENDIAN
   300:         0x00000000,0x00000001,
   301:         0x00000000,0x0000000A,
   302:         0x00000000,0x00000064,
   303:         0x00000000,0x000003E8,
   304:         0x00000000,0x00002710,
   305:         0x00000000,0x000186A0,
   306:         0x00000000,0x000F4240,
   307:         0x00000000,0x00989680,
   308:         0x00000000,0x05F5E100,
   309:         0x00000000,0x3B9ACA00,
   310:         0x00000002,0x540BE400,
   311:         0x00000017,0x4876E800,
   312:         0x000000E8,0xD4A51000,
   313:         0x00000918,0x4E72A000,
   314:         0x00005AF3,0x107A4000,
   315:         0x00038D7E,0xA4C68000,
   316:         0x002386F2,0x6FC10000,
   317:         0x01634578,0x5D8A0000,
   318:         0x0DE0B6B3,0xA7640000,
   319:         0x8AC72304,0x89E80000,
   320: #else
   321:         0x00000001,0x00000000,
   322:         0x0000000A,0x00000000,
   323:         0x00000064,0x00000000,
   324:         0x000003E8,0x00000000,
   325:         0x00002710,0x00000000,
   326:         0x000186A0,0x00000000,
   327:         0x000F4240,0x00000000,
   328:         0x00989680,0x00000000,
   329:         0x05F5E100,0x00000000,
   330:         0x3B9ACA00,0x00000000,
   331:         0x540BE400,0x00000002,
   332:         0x4876E800,0x00000017,
   333:         0xD4A51000,0x000000E8,
   334:         0x4E72A000,0x00000918,
   335:         0x107A4000,0x00005AF3,
   336:         0xA4C68000,0x00038D7E,
   337:         0x6FC10000,0x002386F2,
   338:         0x5D8A0000,0x01634578,
   339:         0xA7640000,0x0DE0B6B3,
   340:         0x89E80000,0x8AC72304,
   341: #endif
   342: };
   343: 
   344: #define fdpowers        _fdp.db
   345: 
   346: #else
   347: #define fdpowers        dpowers
   348: #endif
   349: #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
   350: const static unsigned value     dpowers[] =     {1, 10, 100, 1000, 10000,
   351: #ifdef  __LONG
   352:                                                  100000, 1000000, 10000000, 100000000,
   353:                                                  1000000000
   354: #endif
   355:                                                          };
   356: #endif
   357: #ifdef  SIXTEEN
   358: const static unsigned value     hexpowers[] =   {1, 0x10, 0x100, 0x1000,
   359: #if     __LONG
   360:                                                  0x10000, 0x100000, 0x1000000, 0x10000000
   361: #endif
   362:                                                         };
   363: #endif
   364: #ifdef  EIGHT
   365: const static unsigned value     octpowers[] =   {1, 010, 0100, 01000, 010000, 0100000,
   366: #ifdef  __LONG
   367:                                                 01000000,
   368:                                                  010000000, 0100000000, 01000000000, 010000000000,
   369:                                                  0100000000000
   370: #endif
   371:                                                         };
   372: #endif
   373: 
   374: #ifdef  __FLOAT
   375: 
   376: #define NDDIG   (sizeof fdpowers/sizeof fdpowers[0])
   377: 
   378: #if     DBL_MAX_10_EXP > 120
   379: #define expon   int
   380: #else
   381: #define expon   signed char
   382: #endif
   383: 
   384: extern const double     _powers_[], _npowers_[];
   385: #ifdef  z80
   386: #define _div_to_l_(a, b)        ((unsigned long)((a)/(b)))
   387: #else
   388: extern unsigned long    _div_to_l_(double, double);
   389: #ifdef  _OMNI_CODE_
   390: extern unsigned long    _tdiv_to_l_(float, float);
   391: #ifdef  _HTKC_
   392: #pragma callname _div_to_l_ double
   393: #pragma callname _tdiv_to_l_ float
   394: #endif
   395: #define div_to_l_(a,b)  ((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
   396: #else
   397: #define div_to_l_       _div_to_l_
   398: #endif
   399: #endif
   400: 
   401: /* this routine returns a value to round to the number of decimal
   402:         places specified */
   403: #if __FLOAT
   404: static double
   405: fround(unsigned char prec)
   406: {
   407:         /* prec is guaranteed to be less than NDIG */
   408: 
   409:         if(prec>=110)
   410:                 return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
   411:         else if(prec > 10)
   412:                 return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
   413:         return 0.5 * _npowers_[prec];
   414: }
   415: #endif
   416: 
   417: /* this routine returns a scaling factor equal to 1 to the decimal
   418:    power supplied */
   419: 
   420: static double
   421: scale(expon scl)
   422: {
   423: 
   424:         if(scl < 0) {
   425:                 scl = -scl;
   426:                 if(scl>=110)
   427:                         return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
   428:                 else if(scl > 10)
   429:                         return _npowers_[scl/10+9] * _npowers_[scl%10];
   430:                 return _npowers_[scl];
   431:         }
   432:         if(scl>=110)
   433:                 return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
   434:         else if(scl > 10)
   435:                 return _powers_[scl/10+9] * _powers_[scl%10];
   436:         return _powers_[scl];
   437: }
   438: 
   439: 
   440: #endif  /* __FLOAT */
   441: 
   442: 
   443: 
   444: #ifdef  _HOSTED
   445: #define pputc(c)        (putc(c, fp) != EOF && ++ccnt)
   446: int
   447: vfprintf(FILE * fp, register const  char * f, register va_list ap)
   448: {
   449:         char            cbuf[2];
   450: #else   /* _HOSTED */
   451: int
   452: #if     defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
   453: #define pputc(c)        if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
   454: _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
   455: {
   456: #endif
   457: 
   458: #if     defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
   459: #define pputc(c)        (putch(c) INCR_CNT)
   460: printf(const char * f, ...)
   461: {
   462:         va_list ap;
   463: #define NEED_START
   464: #endif
   465: 
   466: #if     !defined(PRINTF) && defined(VSPRINTF)
   467: 
   468: #ifdef  SPRINTF
   469: sprintf(char * sp, const char * f, ...)
   470: {
   471:         va_list ap;
   472: 
   473:         va_start(ap, f);
   474:         vsprintf(sp, f, ap);
   475:         va_end(ap);
   476: }
   477: int
   478: #endif  // SPRINTF
   479: 
   480: #define pputc(c)        ((*sp++ = (c))INCR_CNT)
   481: vsprintf(char * sp, register const  char * f, register va_list ap)
   482: {
   483: #endif  // VSPRINTF
   484: 
   485: #if     !defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
   486: #define pputc(c)        ((*sp++ = (c))INCR_CNT)
   487: sprintf(char * sp, const  char * f, ...)
   488: {
   489:         va_list ap;
   490: #define NEED_START
   491: #endif
   492: #endif  // HOSTED
   493: 
   494:         signed char             c;
   495: #if     defined(WIDTH) || defined(__FLOAT)
   496:         int             width;
   497: #endif
   498: #ifdef  __LONG
   499:         int             prec;
   500: #else
   501:         signed char     prec;
   502: #endif
   503:         FLAG_SIZE       flag;
   504: #ifdef  RETVALUE
   505:         int             ccnt = 0;
   506: #else
   507: #define ccnt    0
   508: #endif
   509: #ifdef  __FLOAT
   510:         char    d;
   511:         double  fval, integ;
   512:         int             exp;
   513:         double          ival;
   514:         union {
   515:                 unsigned value  _val;
   516:                 struct {
   517:                     CONST char *        _cp;
   518:                     unsigned    _len;
   519:                 }               _str;
   520:         }               _val;
   521: #else   // __FLOAT
   522:         union {
   523:                 unsigned value  _val;
   524:                 struct {
   525:                     CONST char *        _cp;
   526:                     unsigned    _len;
   527:                 }               _str;
   528:         }               _val;
   529: #endif  // __FLOAT
   530: 
   531: #define val     _val._val
   532: #define cp      _val._str._cp
   533: #define len     _val._str._len
   534: 
   535:         
   536: #ifdef  NEED_START
   537:         va_start(ap, f);
   538: #endif
   539: 
   540:         while(c = *f++) {
   541: #ifdef  ANYFORMAT
   542:                 if(c != '%')
   543: #endif  //ANYFORMAT
   544:                 {
   545:                         pputc(c);
   546:                         continue;
   547:                 }
   548: #ifdef  ANYFORMAT
   549: #ifdef  WIDTH
   550:                 width = 0;
   551: #endif
   552:                 flag = 0;
   553: #if     defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
   554:                 for(;;) {
   555:                         switch(*f) {
   556: #ifdef  LEFT
   557:                         case '-':
   558:                                 flag |= LEFT;
   559:                                 f++;
   560:                                 continue;
   561: #endif
   562: 
   563: #ifdef  SPCSIGN
   564:                         case ' ':
   565:                                 flag |= SPCSIGN;
   566:                                 f++;
   567:                                 continue;
   568: #endif
   569: 
   570: #ifdef  MANSIGN
   571:                         case '+':
   572:                                 flag |= MANSIGN;
   573:                                 f++;
   574:                                 continue;
   575: #endif
   576: #ifdef  ALTERN
   577:                         case '#':
   578:                                 flag |= ALTERN;
   579:                                 f++;
   580:                                 continue;
   581: #endif
   582: #ifdef  FILL
   583:                         case '0':
   584:                                 flag |= FILL;
   585:                                 f++;
   586:                                 continue;
   587: #endif
   588:                         }
   589:                         break;
   590:                 }
   591: #endif
   592: #if     defined(MANSIGN) && defined(SPCSIGN)
   593:                 if(flag & MANSIGN)
   594:                         flag &= ~SPCSIGN;
   595: #endif
   596: #if     defined(LEFT) && defined(FILL)
   597:                 if(flag & LEFT)
   598:                         flag &= ~FILL;
   599: #endif
   600: #ifdef  WIDTH
   601:                 if(isdigit((unsigned)*f)) {
   602:                         width = 0;
   603:                         do
   604:                                 width = width*10 + *f++ - '0';
   605:                         while(isdigit((unsigned)*f));
   606: #ifdef  STAR
   607:                 } else if(*f == '*') {
   608:                         width = va_arg(ap, int);
   609:                         f++;
   610: #endif
   611:                 }
   612: #endif
   613: #ifdef  PRECISION
   614:                 if(*f == '.') {
   615:                         flag |= PRECISION;
   616:                         f++;
   617: #ifdef  STAR
   618:                         if(*f == '*') {
   619:                                 prec = va_arg(ap, int);
   620:                                 f++;
   621:                         } else
   622: #endif
   623:                         {
   624:                                 prec = 0;
   625:                                 while(isdigit((unsigned)*f))
   626:                                         prec = prec*10 + *f++ - '0';
   627:                         }
   628:                 } else {
   629:                         prec = 0;
   630: #ifdef  DEFPREC
   631:                         flag |= DEFPREC;
   632: #endif  // DEFPREC
   633:                 }
   634: #endif  // PRECISION
   635: #if     defined(__LONG) && defined(LONG)
   636: loop:
   637: #endif
   638:                 switch(c = *f++) {
   639: 
   640:                 case 0:
   641:                         goto alldone;
   642: 
   643: #ifdef  LONG
   644:                 case 'l':
   645: #ifdef  __LONG
   646:                         flag |= LONG;
   647:                         goto loop;
   648: #else
   649:                         cp = "(non-long printf)";
   650:                         goto strings;
   651: #endif
   652: #endif
   653: 
   654: #ifdef  FLOATFORMAT
   655: #ifndef __FLOAT
   656:                 case 'E':
   657:                 case 'f':
   658:                 case 'e':
   659:                 case 'G':
   660:                 case 'g':
   661:                         cp = "(non-float printf)";
   662:                         goto strings;
   663: #else
   664: #ifdef  FFMT
   665:                 case 'f':
   666:                         flag |= FFMT;
   667:                         break;
   668: #endif
   669: 
   670: #ifdef  EFMT
   671: #ifdef  UPCASE
   672:                 case 'E':
   673:                         flag |= UPCASE;
   674: #endif
   675:                 case 'e':
   676:                         flag |= EFMT;
   677:                         break;
   678: #endif
   679: 
   680: #ifdef  GFMT
   681: #ifdef  UPCASE
   682:                 case 'G':
   683:                         flag |= UPCASE;
   684: #endif
   685:                 case 'g':
   686:                         flag |= GFMT;
   687:                         break;
   688: #endif  // GFMT
   689: #endif
   690: #endif  // FLOATFORMAT
   691: #ifdef  EIGHT
   692:                 case 'o':
   693: #ifdef  MULTRAD
   694:                         flag |= EIGHT;
   695: #endif
   696:                         break;
   697: #endif
   698: 
   699: #ifdef  TEN
   700:                 case 'd':
   701:                 case 'i':
   702:                         break;
   703: #endif
   704: 
   705: #ifdef  POINTER
   706:                 case 'p':
   707: #if     i8086 && LARGE_DATA
   708:                         flag |= LONG;
   709: #elif   _PIC18 && LARGE_DATA
   710:                         flag |= POINTER;
   711: #endif
   712: #endif  // POINTER
   713: #ifdef  SIXTEEN
   714: #ifdef  HEXUPCASE
   715:                 case 'X':
   716: #ifdef  UPCASE
   717:                         flag |= UPCASE;
   718: #endif
   719: #endif
   720: #if     defined(HEXLOWCASE) || !defined(UPCASE)
   721:                 case 'x':
   722: #endif
   723: #ifdef  MULTRAD
   724:                         flag |= SIXTEEN;
   725: #endif
   726:                         break;
   727: #endif  // SIXTEEN
   728: 
   729: #if     defined(STRING) || defined(PERCPERC)
   730: #ifdef  STRING
   731:                 case 's':
   732: #if     i8086 && SMALL_DATA
   733:                         if(flag & LONG)
   734:                                 cp = va_arg(ap, far char *);
   735:                         else
   736: #endif
   737:                                 cp = va_arg(ap, const char *);
   738: #endif  // STRING
   739: #if     !defined(__FLOAT) && !defined(CUSTOM_PRINTF)
   740: strings:
   741: #endif
   742: #ifdef  STRING
   743:                         if(!cp)
   744:                                 cp = "(null)";
   745: #endif
   746: #if     defined(WIDTH) || defined(PRECISION)
   747: #if     defined(STRING)
   748:                         len = 0;
   749:                         while(cp[len])
   750:                                 len++;
   751: #endif
   752: #ifdef  PERCPERC
   753: dostring:
   754: #endif
   755: #ifdef  PRECISION
   756:                         if(prec && prec < len)
   757:                                 len = prec;
   758: #endif  // PRECISION
   759: #ifdef  WIDTH
   760:                         if(width > len)
   761:                                 width -= len;
   762:                         else
   763:                                 width = 0;
   764: #ifdef  LEFT
   765:                         if(!(flag & LEFT))
   766: #endif  // LEFT
   767:                                 while(width--)
   768:                                         pputc(' ');
   769: #endif  // WIDTH
   770:                         while(len--)
   771:                                 pputc(*cp++);
   772: #ifdef  LEFT
   773:                         if(flag & LEFT)
   774:                                 while(width--)
   775:                                         pputc(' ');
   776: #endif  // LEFT
   777:                         continue;
   778: #else   // WIDTH || PRECISION
   779: #if     defined(STRING)
   780:                         while(*cp)
   781:                                 pputc(*cp++);
   782:                         continue;
   783: #endif
   784: #endif  // WIDTH || PRECISION
   785: #endif  // defined(STRING) || defined(PERCPERC)
   786: #ifdef  CHAR
   787:                 case 'c':
   788: #if     _HOSTED
   789:                         val = va_arg(ap, int);
   790:                         c = val >> 8;
   791:                         if(flag & LONG && c && (unsigned char)c != 0xFF) {
   792:                                 cbuf[0] = c;
   793:                                 cbuf[1] = val;
   794:                                 len = 2;
   795:                         } else {
   796:                                 cbuf[0] = val;
   797:                                 len = 1;
   798:                         }
   799:                         cp = cbuf;
   800:                         goto dostring;
   801: #else
   802:                         c = va_arg(ap, int);
   803: #endif  // _HOSTED
   804: #endif  // CHAR
   805:                 default:
   806: #ifdef  PERCPERC
   807: #if     defined(WIDTH) || defined(PRECISION)
   808:                         cp = (char *)&c;
   809:                         len = 1;
   810:                         goto dostring;
   811: #else
   812:                         pputc(c);
   813:                         continue;
   814: #endif
   815: #else   // PERCPERC
   816:                         continue;
   817: #endif
   818: 
   819: #ifdef  UNSIGN
   820:                 case 'u':
   821:                         flag |= UNSIGN;
   822:                         break;
   823: #endif
   824: 
   825:                 }
   826: #endif  // ANYFORMAT
   827: #ifdef  __FLOAT
   828:                 if(flag & (FLOATFORMAT)) {
   829: #ifdef  DEFPREC
   830:                         if(flag & DEFPREC)
   831: #endif
   832:                                 prec = 6;
   833:                         fval = va_arg(ap, double);      // source the floating point value
   834:                         if(fval < 0.0) {
   835:                                 fval = -fval;           // get the absolute value
   836:                                 flag |= NEGSIGN;
   837:                         }
   838:                         exp = 0;                /* If the number is zero, the exponent is zero. */
   839:                         if( fval!=0) {          /* If the number is non-zero, find the exponent. */
   840:                                 frexp(fval, &exp);              /* get binary exponent */
   841:                                 exp--;                          /* adjust 0.5 -> 1.0 */
   842:                                 exp *= 3;
   843:                                 exp /= 10;                      /* estimate decimal exponent */
   844:                                 if(exp < 0)
   845:                                         exp--;
   846:                                 // the following line can cause "recursive call" errors because scale calls
   847:                                 // ftmul, and is used when evaluating an argument to ftmul
   848:                                 //integ = fval * scale(-exp);
   849:                                 integ = scale(-exp);            // replaced with this
   850:                                 integ *= fval;
   851:                                 if(integ < 1.0)
   852:                                         exp--;
   853:                                 else if(integ >= 10.0)
   854:                                         exp++;
   855:                         }
   856: #if     defined(EFMT) || defined(GFMT)
   857:                         if(exp <= 0)    // value is 0.??? (neg expnt) whole characters = 1 (allow zero)
   858:                                 c = 1;
   859:                         else
   860:                                 c = exp;
   861:                         if(
   862: #ifdef  EFMT
   863:                                         flag & EFMT
   864: #ifdef  GFMT
   865:                                         ||
   866: #endif
   867: #endif
   868: #ifdef  GFMT
   869:                                         flag & GFMT && (exp < -4 || exp >= (int)prec)
   870: #endif
   871:                                 ) {     /* use e format */
   872: #ifdef  GFMT
   873:                                 if(prec && flag & GFMT)
   874:                                         prec--;         /* g format precision includes integer digit */
   875: #endif
   876:                                 if((unsigned)prec > NDDIG - 2)
   877:                                         c = NDDIG - 2;
   878:                                 else
   879:                                         c = prec;
   880:                                 if( fval!=0) {  /* Normalise only if the number is non-zero. */
   881:                                         fval /= scale(exp-c);
   882: #if     DOUBLE
   883:                                         ival = _dto64i(fval);
   884:                                         if(fval - _64itod(ival) >= 0.5) {
   885:                                                 fval += 0.5;
   886:                                                 ival = _dto64i(fval);
   887:                                         }
   888:                                         if(ival >= fdpowers[c+1]) {
   889:                                                 fval *= 1e-1;
   890:                                                 exp++;
   891:                                         } else if(ival < fdpowers[c]) {
   892:                                                 fval *= 10.0;
   893:                                                 exp--;
   894:                                         }
   895: #else   
   896:                                         if(fval - (double)(unsigned long)fval >= 0.5)
   897:                                                 fval += 0.5;
   898:                                         if((unsigned long)fval >= fdpowers[c+1]) {
   899:                                                 fval *= 1e-1;
   900:                                                 exp++;
   901:                                         } else if((unsigned long)fval < fdpowers[c]) {
   902:                                                 fval *= 10.0;
   903:                                                 exp--;
   904:                                         }
   905: #endif
   906:                                 }
   907: #if defined(GFMT) && defined(ALTERN)
   908:                                 if(flag & GFMT && !(flag & ALTERN)) {           /* g format, precision means something different */
   909:                                         if(prec > (int)(NDDIG))
   910:                                                 prec = NDDIG;
   911: #if     DOUBLE
   912:                                         ival = _dto64i(fval);
   913:                                         while(ival != 0.0 && _mod64i10(ival) == 0) {
   914:                                                 prec--;
   915:                                                 ival = _div64(ival, fdpowers[1]);
   916:                                         }
   917: #else
   918:                                         val = (unsigned long)fval;
   919:                                         while(val && val % 10 == 0) {
   920:                                                 prec--;
   921:                                                 val /= 10;
   922:                                         }
   923: #endif
   924:                                         if(prec < c) {
   925:                                                 fval /= scale(c-prec);
   926:                                                 c = prec;
   927:                                         }
   928: 
   929:                                 }
   930: #endif
   931: #ifdef  WIDTH
   932:                                 width -=  prec + 5;
   933: #ifdef  ALTERN
   934:                                 if(prec || flag & ALTERN)
   935:                                         width--;
   936: #endif
   937:                                 if(flag & NEGSIGN)
   938:                                         width--;
   939: #if     DBL_MAX_10_EXP >= 100
   940: #if     DBL_MAX_10_EXP >= 1000
   941:                                 if(exp >= 1000 || exp <= -1000) /* 4 digit exponent */
   942:                                         width--;
   943: #endif
   944:                                 if(exp >= 100 || exp <= -100)   /* 3 digit exponent */
   945:                                         width--;
   946: #endif
   947: #endif  // WIDTH
   948: #ifdef  FILL
   949:                                 if(flag & FILL) {
   950: #if defined(MANSIGN) && defined(SPCSIGN)
   951:                                         if(flag & MANSIGN)
   952:                                                 pputc(flag & SPCSIGN ? '-' : '+');
   953:                                         else if(flag & SPCSIGN)
   954:                                                 pputc(' ');
   955: #endif
   956:                                         while(width > 0) {
   957:                                                 pputc('0');
   958:                                                 width--;
   959:                                         }
   960:                                 } else
   961: #endif  // FILL
   962:                                 {
   963: #ifdef  WIDTH
   964: #ifdef  LEFT
   965:                                         if(!(flag & LEFT))
   966: #endif
   967:                                                 while(width > 0) {
   968:                                                         pputc(' ');
   969:                                                         width--;
   970:                                                 }
   971: #endif  // WIDTH
   972: #ifdef  MANSIGN
   973:                                         if(flag & MANSIGN)
   974:                                                 putsign();
   975: #else
   976:                                         if(flag & NEGSIGN)
   977:                                                 pputc('-');
   978: #endif  // MANSIGN
   979: #ifdef  SPCSIGN
   980:                                         else if(flag & SPCSIGN)
   981:                                                 pputc(' ');
   982: #endif  // SPCSIGN
   983:                                 }
   984: #if     DOUBLE
   985:                                 ival = _dto64i(fval);
   986:                                 pputc(_div64ir(ival, fdpowers[c]) + '0');
   987: #else
   988:                                 val = (unsigned long)fval;
   989:                                 pputc(val/dpowers[c] + '0');
   990:                                 val %= dpowers[c];
   991: #endif
   992: #ifdef  ALTERN
   993:                                 if(prec || flag & ALTERN)
   994: #else
   995:                                 if(prec)
   996: #endif
   997:                                 {
   998:                                         pputc('.');
   999:                                         prec -= c;
  1000:                                         while(c--) {
  1001: #if     DOUBLE
  1002:                                                 pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
  1003: #else
  1004: #ifdef  GFMT
  1005:                                                 if(flag & GFMT && val == 0) {
  1006:                                                         prec = c = 0;
  1007:                                                         break;
  1008:                                                 }
  1009: #endif
  1010:                                                 pputc('0' + (val/dpowers[c]));
  1011:                                                 val %= dpowers[c];
  1012: #endif
  1013:                                         }
  1014:                                         while(prec) {
  1015:                                                 pputc('0');
  1016:                                                 prec--;
  1017:                                         }
  1018:                                 }
  1019: #ifdef  UPCASE
  1020:                                 if(flag & UPCASE)
  1021:                                         pputc('E');
  1022:                                 else
  1023: #endif
  1024:                                         pputc('e');
  1025:                                 if(exp < 0) {
  1026:                                         exp = -exp;
  1027:                                         pputc('-');
  1028:                                 } else
  1029:                                         pputc('+');
  1030: #if     DBL_MAX_10_EXP >= 100
  1031: #if     DBL_MAX_10_EXP >= 1000
  1032:                                 if(exp >= 1000) {
  1033:                                         pputc(exp / 1000 + '0');
  1034:                                         exp %= 1000;
  1035:                                 }
  1036: #endif
  1037:                                 if(exp >= 100) {
  1038:                                         pputc(exp / 100 + '0');
  1039:                                         exp %= 100;
  1040:                                 }
  1041: #endif
  1042:                                 pputc(exp / 10 + '0');
  1043:                                 pputc(exp % 10 + '0');
  1044: #ifdef  LEFT
  1045:                                 if((flag & LEFT) && width > 0)
  1046:                                         do
  1047:                                                 pputc(' ');
  1048:                                         while(--width);
  1049: #endif  // LEFT
  1050:                                         continue;
  1051:                                 }
  1052: #endif  // EFMT || GFMT
  1053:                                 /* here for f format */
  1054: #if     DOUBLE
  1055: #ifdef  GFMT
  1056:                                 if(flag & GFMT) {
  1057:                                         if(exp < 0)     // fractional part only
  1058:                                                 prec -= exp-1;
  1059:                                         ival = _dto64i(fval);
  1060:                                         for(c = 1 ; c != NDDIG ; c++)
  1061:                                                 if(ival < fdpowers[c])
  1062:                                                         break;
  1063:                                         if(prec > NDDIG)
  1064:                                                 prec = NDDIG;
  1065:                                         prec -= c;
  1066:                                         ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
  1067:                                         // see how many zeros are at the end of the fractional part
  1068:                                         while(prec && _mod64i10(ival) == 0) {
  1069:                                                 prec--;
  1070:                                                 ival = _div64(ival, fdpowers[1]);
  1071:                                         }
  1072:                                 }
  1073: #endif  // GFMT
  1074:                                 if(prec <= (int)NDDIG)
  1075:                                         fval += fround(prec);
  1076:                                 if(exp > (int)(NDDIG)-2) {
  1077:                                         exp -= NDDIG-2;
  1078:                                         ival = _divto64i(fval, scale(exp));
  1079:                                         fval = 0.0;
  1080:                                 } else {
  1081:                                         ival = _dto64i(fval);
  1082:                                         fval -= _64itod(ival);
  1083:                                         exp = 0;
  1084:                                 }
  1085:                                 for(c = 1 ; c != NDDIG ; c++)
  1086:                                         if(ival < fdpowers[c])
  1087:                                                 break;
  1088: #else   // DOUBLE
  1089: #ifdef  GFMT
  1090:                                 if(flag & GFMT) {
  1091:                                         if(exp < 0)     // fractional part only
  1092:                                                 prec -= (exp+1);
  1093:                                         // count number of digits in the integral part (this is for %g)
  1094:                                         val = (unsigned long)fval;
  1095:                                         for(c = 0 ; c != NDDIG ; c++)
  1096:                                                 if(val < fdpowers[c])
  1097:                                                         break;
  1098:                                         prec -= c;              // reduce precision by this
  1099:                                         if(prec <= NDIG)
  1100:                                                 fval += fround(prec);
  1101:                                         // get fractional part and count trailing zeros - reduce
  1102:                                         // prec as required
  1103:                                         {
  1104:                                                 double  temp;
  1105:                                                 temp = scale(prec);
  1106:                                                 temp *= fval - (double)val;
  1107:                                                 val = (unsigned long)temp;
  1108:                                         }
  1109:                                         while(prec && val % 10 == 0) {
  1110:                                                 val /= 10;
  1111:                                                 prec--;
  1112:                                         }
  1113:                                 } else
  1114: #endif  //GFMT
  1115:                                         if(prec <= NDIG)
  1116:                                                 fval += fround(prec);
  1117: 
  1118:                                 /* ~4.2e9 is the largest float that will fit into a 32-bit long */
  1119:                                 if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
  1120:                                         // fval is > 4.2e9
  1121:                                         // new exp must be such that div_to_l() is < 4.2e9
  1122:                                         // OLD CODE:    if(fval / scale(exp) < 4.294967296){
  1123:                                         if(integ < 4.294967296){
  1124:                                                 exp -= NDDIG-1;
  1125:                                         }else{
  1126:                                                 exp -= NDDIG-2;
  1127:                                         }
  1128:                                         integ = scale(exp);
  1129:                                         val = div_to_l_(fval, integ);
  1130:                                         //val = _div_to_l_(integ, fval);
  1131:                                         //val = (long)(integ * fval);   // fit as much signifigant data into the long as it can hold
  1132:                                         fval = 0.0;     // There will be no fractional component
  1133:                                 } else {
  1134:                                         val = (unsigned long)fval;
  1135:                                         fval -= (double)val;
  1136:                                         exp = 0;
  1137:                                 }
  1138:                                 // count digits in integral part
  1139:                                 for(c = 1 ; c != NDDIG ; c++)
  1140:                                         if(val < fdpowers[c])
  1141:                                                 break;
  1142: #endif  // DOUBLE
  1143: #ifdef  WIDTH
  1144:                                 // at this point, c contains the number of whole-number digits to print
  1145:                                 width -= prec + c + exp;
  1146:                                 if(
  1147: #ifdef  ALTERN
  1148:                                                 flag & ALTERN ||
  1149: #endif
  1150:                                                 prec)
  1151:                                         width--;                // allow for decimal point
  1152:                                 if(flag & NEGSIGN)
  1153:                                         width--;
  1154: #endif  // WIDTH
  1155: #ifdef  FILL
  1156:                                 if(flag & FILL) {
  1157: #ifdef  MANSIGN
  1158:                                         if(flag & MANSIGN)
  1159:                                                 putsign();
  1160: #endif
  1161: #if defined(MANSIGN) && defined(SPCSIGN)
  1162:                                         else
  1163: #endif
  1164: #ifdef  SPCSIGN
  1165:                                         if(flag & SPCSIGN)
  1166:                                                 pputc(' ');
  1167: #endif  // SPCSIGN
  1168: #ifdef  WIDTH
  1169:                                         while(width > 0) {
  1170:                                                 pputc('0');
  1171:                                                 width--;
  1172:                                         }
  1173: #endif  // WIDTH
  1174:                                 } else
  1175: #endif  // FILL
  1176:                                 {
  1177: #ifdef  LEFT
  1178:                                         if(!(flag & LEFT))
  1179: #endif
  1180: #ifdef  WIDTH
  1181:                                         while(width > 0) {
  1182:                                                 pputc(' ');
  1183:                                                 width--;
  1184:                                         }
  1185: #endif  // WIDTH
  1186: #ifdef  MANSIGN
  1187:                                 if(flag & MANSIGN)
  1188: #else
  1189:                                 if(flag & NEGSIGN)
  1190: #endif  // MANSIGN
  1191:                                         putsign();
  1192: #ifdef  SPCSIGN
  1193:                                 else if(flag & SPCSIGN)
  1194:                                         pputc(' ');
  1195: #endif  // SPCSIGN
  1196:                         }
  1197:                         while(c--) {
  1198: #if     DOUBLE
  1199:                                 pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
  1200: #else
  1201:                                 pputc('0' + (val/dpowers[c])%10);
  1202: #endif  // DOUBLE
  1203:                         }
  1204:                         while(exp > 0) {
  1205:                                 pputc('0');
  1206:                                 exp--;
  1207:                         }
  1208:                         if(prec > (int)(NDDIG-2))
  1209:                                 c = NDDIG-2;
  1210:                         else
  1211:                                 c = prec;
  1212:                         prec -= c;
  1213: #ifdef  ALTERN
  1214:                         if(c || flag & ALTERN)
  1215: #else
  1216:                         if(c)
  1217: #endif
  1218:                                 pputc('.');
  1219: #if     DOUBLE
  1220:                         ival = _dto64i(fval * scale(c));
  1221:                         while(c)
  1222:                                 pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
  1223: #else   // DOUBLE
  1224:                         val = (long)(fval * scale(c));
  1225:                         while(c--) {
  1226:                                 pputc('0' + (val/dpowers[c])%10);
  1227:                                 val %= dpowers[c];
  1228:                         }
  1229: #endif  // DOUBLE
  1230:                         while(prec) {
  1231:                                 pputc('0');
  1232:                                 prec--;
  1233:                         }
  1234: #ifdef  LEFT
  1235:                         if((flag & LEFT) && width > 0)
  1236:                                 do
  1237:                                         pputc(' ');
  1238:                                 while(--width);
  1239: #endif
  1240:                         continue;
  1241:                 }
  1242: #endif  /* __FLOAT */
  1243: 
  1244: #if     defined(TEN)
  1245: #ifdef  BASEM
  1246:                 if((flag & BASEM) == TEN)
  1247: #endif  //BASEM
  1248:                 {
  1249: #ifdef  LONG
  1250:                         if(flag & LONG)
  1251:                                 val = va_arg(ap, long);
  1252:                         else
  1253: #endif  // LONG
  1254:                                 val = (value)va_arg(ap, int);
  1255: #ifdef  NEGSIGN
  1256:                         if((value)val < 0) {
  1257:                                 flag |= NEGSIGN;
  1258:                                 val = -val;
  1259:                         }
  1260: #endif
  1261:                 }
  1262: #ifdef  BASEM
  1263:                 else
  1264: #endif
  1265: #endif  // TEN
  1266: 
  1267: #if     defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
  1268:                 {
  1269: #ifdef  __LONG
  1270: #if     defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
  1271:                         if(flag & POINTER)
  1272:                                 val = (unsigned long)va_arg(ap, far char *);
  1273:                         else
  1274: #endif
  1275: #ifdef  LONG
  1276:                                 if(flag & LONG)
  1277:                                 val = va_arg(ap, unsigned long);
  1278:                         else
  1279: #endif  // LONG
  1280: #endif  // __LONG
  1281:                                 val = va_arg(ap, unsigned);
  1282:                 }
  1283: #endif  // EIGHT or SIXTEEN or UNSIGN
  1284: #ifdef  PRECISION
  1285:                 if(prec == 0 && val == 0)
  1286:                         prec++;
  1287: #endif
  1288: #ifdef  MULTRAD
  1289:                 switch((unsigned char)(flag & BASEM)) {
  1290: #endif
  1291: #if     defined(TEN) || defined(UNSIGN)
  1292: #ifdef  MULTRAD
  1293: #ifdef  TEN
  1294:                 case TEN:
  1295: #endif
  1296: #ifdef  UNSIGN
  1297:                 case UNSIGN:
  1298: #endif
  1299: #endif  // MULTRAD
  1300:                         for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
  1301:                                 if(val < dpowers[c])
  1302:                                         break;
  1303: #ifdef  MULTRAD
  1304:                         break;
  1305: #endif
  1306: #endif  // TEN || UNSIGN
  1307: #ifdef  SIXTEEN
  1308: #ifdef  MULTRAD
  1309:                 case SIXTEEN:
  1310: #endif  // MULTRAD
  1311:                         for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
  1312:                                 if(val < hexpowers[c])
  1313:                                         break;
  1314: #ifdef  MULTRAD
  1315:                         break;
  1316: #endif
  1317: #endif
  1318: 
  1319: #ifdef  EIGHT
  1320: #ifdef  MULTRAD
  1321:                 case EIGHT:
  1322: #endif  // MULTRAD
  1323:                         for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
  1324:                                 if(val < octpowers[c])
  1325:                                         break;
  1326: #ifdef  MULTRAD
  1327:                         break;
  1328: #endif
  1329: #endif
  1330: #ifdef  MULTRAD
  1331:                 }
  1332: #endif
  1333: #ifdef  PRECISION
  1334:                 if(c < prec)
  1335:                         c = prec;
  1336:                 else if(prec < c)
  1337:                         prec = c;
  1338: #endif
  1339: #if     defined(WIDTH) && defined(NEGSIGN)
  1340:                 if(width && flag & NEGSIGN)
  1341:                         width--;
  1342: #ifdef  PRECISION
  1343:                 if(flag & PRECISION) {
  1344:                         if(width > prec)
  1345:                                 width -= prec;
  1346:                         else
  1347:                                 width = 0;
  1348:                 }
  1349: #endif
  1350: #ifdef  ALTERN
  1351: #ifdef  EIGHT
  1352:                 if((flag & (
  1353: #ifdef  FILL
  1354:                                                 FILL|
  1355: #endif
  1356:                                                         BASEM|ALTERN)) == (EIGHT|ALTERN)) {
  1357:                         if(width)
  1358:                                 width--;
  1359:                 } else
  1360: #endif  // EIGHT
  1361: #if     defined(SIXTEEN)
  1362: #ifdef  BASEM
  1363:                 if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
  1364: #else
  1365:                 if(flag & ALTERN) {
  1366: #endif
  1367:                         if(width > 2)
  1368:                                 width -= 2;
  1369:                         else
  1370:                                 width = 0;
  1371:                 }
  1372: #endif  // SIXTEEN
  1373: #endif  // ALTERN
  1374: #endif  // WIDTH
  1375: #ifdef  WIDTH
  1376:                 if(width > c)
  1377:                         width -= c;
  1378:                 else
  1379:                         width = 0;
  1380: #endif
  1381: #ifdef  FILL
  1382:                 if(flag & FILL) {
  1383: #ifdef  MANSIGN
  1384:                         if(flag & MANSIGN)
  1385:                                 putsign();
  1386: #elif defined(NEGSIGN)
  1387:                         if(flag & NEGSIGN)
  1388:                                 pputc('-');
  1389: #endif
  1390: #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
  1391:                         else
  1392: #endif  // MANSIGN
  1393: #ifdef  SPCSIGN
  1394:                         if(flag & SPCSIGN)
  1395:                                 pputc(' ');
  1396: #endif
  1397: #if defined(ALTERN) && defined(SIXTEEN)
  1398:                         else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
  1399:                                 pputc('0');
  1400: #if     defined(HEXUPCASE) && defined(HEXLOWCASE)
  1401:                                 pputc(flag & UPCASE ? 'X' : 'x');
  1402: #elif defined(HEXUPCASE)
  1403:                                 pputc('X');
  1404: #else
  1405:                                 pputc('x');
  1406: #endif  // HEXUPCASE
  1407:                         }
  1408: #endif  // ALTERN
  1409: #ifdef  WIDTH
  1410:                         if(width)
  1411:                                 do
  1412:                                         pputc('0');
  1413:                                 while(--width);
  1414: #endif  // WIDTH
  1415:                 } else
  1416: #endif  //FILL
  1417:                 {
  1418: #ifdef  WIDTH
  1419:                         if(width
  1420: #ifdef  LEFT
  1421:                                         && !(flag & LEFT)
  1422: #endif
  1423:                                         )
  1424:                                 do
  1425:                                         pputc(' ');
  1426:                                 while(--width);
  1427: #endif  // WIDTH
  1428: #ifdef  MANSIGN
  1429:                         if(flag & MANSIGN)
  1430:                                 putsign();
  1431: #else
  1432: #ifdef  NEGSIGN
  1433:                         if(flag & NEGSIGN)
  1434:                                 pputc('-');
  1435: #endif
  1436: #endif  // MANSIGN
  1437: #ifdef  SPCSIGN
  1438:                         else if(flag & SPCSIGN)
  1439:                                 pputc(' ');
  1440: #endif
  1441: #ifdef  ALTERN
  1442: #ifdef  EIGHT
  1443:                         if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
  1444:                                 pputc('0');
  1445:                         else
  1446: #endif  // EIGHT
  1447: #ifdef  SIXTEEN
  1448: #ifdef  BASEM
  1449:                         if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
  1450: #else
  1451:                         if(flag & ALTERN) {
  1452: #endif
  1453:                                 pputc('0');
  1454: #if     defined(HEXUPCASE) && defined(HEXLOWCASE)
  1455:                                 pputc(flag & UPCASE ? 'X' : 'x');
  1456: #elif defined(HEXUPCASE)
  1457:                                 pputc('X');
  1458: #else
  1459:                                 pputc('x');
  1460: #endif
  1461:                         }
  1462: #endif  // SIXTEEN
  1463: #endif  // ALTERN
  1464:                 }
  1465: #if     defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
  1466: #ifndef PRECISION
  1467:                 prec = c;
  1468: #endif
  1469:                 while(prec--) {
  1470: #ifdef  MULTRAD
  1471:                         switch((unsigned char)(flag & BASEM))
  1472: #endif
  1473:                         {
  1474: 
  1475: #if     defined(TEN) || defined(UNSIGN)
  1476: #ifdef  MULTRAD
  1477: #ifdef  TEN
  1478:                 case TEN:
  1479: #endif
  1480: #ifdef  UNSIGN
  1481:                 case UNSIGN:
  1482: #endif
  1483: #endif  // MULTRAD
  1484:                                 c = (val / dpowers[prec]) % 10 + '0';
  1485: #ifdef  MULTRAD
  1486:                                 break;
  1487: #endif
  1488: #endif  // TEN || UNSIGN
  1489: 
  1490: #ifdef  SIXTEEN
  1491: #ifdef  MULTRAD
  1492:                         case SIXTEEN:
  1493: #endif
  1494: #if     defined(HEXLOWCASE) && defined(HEXUPCASE)
  1495:                                 c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[(val / hexpowers[prec]) & 0xF];
  1496: #elif   defined(HEXUPCASE)
  1497:                                 c = "0123456789ABCDEF"[(val / hexpowers[prec]) & 0xF];
  1498: #else
  1499:                                 c = "0123456789abcdef"[(val / hexpowers[prec]) & 0xF];
  1500: #endif  //HEXCASE
  1501: #ifdef  MULTRAD
  1502:                                 break;
  1503: #endif
  1504: #endif
  1505: 
  1506: #ifdef  EIGHT
  1507: #ifdef  MULTRAD
  1508:                         case EIGHT:
  1509: #endif  // MULTRAD
  1510:                                 c = ((val / octpowers[prec]) & 07) + '0';
  1511: #ifdef  MULTRAD
  1512:                                 break;
  1513: #endif  // MULTRAD
  1514: #endif  // EIGHT
  1515:                         }
  1516:                         pputc(c);
  1517:                 }
  1518: #endif  // 16 or 10 or 8
  1519: #ifdef  LEFT
  1520:                 if((flag & LEFT) && width > 0)
  1521:                         do
  1522:                                 pputc(' ');
  1523:                         while(--width);
  1524: #endif  // LEFT
  1525:         }
  1526: #ifdef  ANYFORMAT
  1527: alldone:
  1528: #endif  // ANYFORMAT
  1529: #if     !defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
  1530:         *sp = 0;
  1531: #endif
  1532:         return ccnt;
  1533: }
  1534: 
